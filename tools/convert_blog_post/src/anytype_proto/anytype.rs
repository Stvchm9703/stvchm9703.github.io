// This file is @generated by prost-build.
///
/// Event â€“ type of message, that could be sent from a middleware to the corresponding front-end.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Event {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<event::Message>,
    #[prost(string, tag = "2")]
    pub context_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub initiator: ::core::option::Option<crate::anytype_proto::anytype_model::Account>,
    #[prost(string, tag = "4")]
    pub trace_id: ::prost::alloc::string::String,
}
/// Nested message and enum types in `Event`.
pub mod event {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Message {
        #[prost(string, tag = "132")]
        pub space_id: ::prost::alloc::string::String,
        #[prost(
            oneof = "message::Value",
            tags = "1, 201, 202, 203, 204, 205, 16, 50, 51, 52, 53, 54, 65, 55, 60, 61, 62, 63, 64, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 14, 15, 17, 21, 25, 36, 37, 40, 19, 20, 29, 35, 38, 39, 124, 123, 125, 126, 127, 24, 23, 31, 32, 33, 34, 100, 101, 102, 103, 110, 111, 112, 113, 118, 114, 115, 116, 117, 119, 122, 120, 121, 128, 129, 130, 134, 135, 131, 133"
        )]
        pub value: ::core::option::Option<message::Value>,
    }
    /// Nested message and enum types in `Message`.
    pub mod message {
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Value {
            #[prost(message, tag = "1")]
            AccountShow(super::account::Show),
            #[prost(message, tag = "201")]
            AccountDetails(super::account::Details),
            #[prost(message, tag = "202")]
            AccountConfigUpdate(super::account::config::Update),
            #[prost(message, tag = "203")]
            AccountUpdate(super::account::Update),
            #[prost(message, tag = "204")]
            AccountLinkChallenge(super::account::LinkChallenge),
            #[prost(message, tag = "205")]
            AccountLinkChallengeHide(super::account::LinkChallengeHide),
            #[prost(message, tag = "16")]
            ObjectDetailsSet(super::object::details::Set),
            #[prost(message, tag = "50")]
            ObjectDetailsAmend(super::object::details::Amend),
            #[prost(message, tag = "51")]
            ObjectDetailsUnset(super::object::details::Unset),
            #[prost(message, tag = "52")]
            ObjectRelationsAmend(super::object::relations::Amend),
            #[prost(message, tag = "53")]
            ObjectRelationsRemove(super::object::relations::Remove),
            #[prost(message, tag = "54")]
            ObjectRemove(super::object::Remove),
            #[prost(message, tag = "65")]
            ObjectClose(super::object::Close),
            #[prost(message, tag = "55")]
            ObjectRestrictionsSet(super::object::restrictions::Set),
            #[prost(message, tag = "60")]
            SubscriptionAdd(super::object::subscription::Add),
            #[prost(message, tag = "61")]
            SubscriptionRemove(super::object::subscription::Remove),
            #[prost(message, tag = "62")]
            SubscriptionPosition(super::object::subscription::Position),
            #[prost(message, tag = "63")]
            SubscriptionCounters(super::object::subscription::Counters),
            #[prost(message, tag = "64")]
            SubscriptionGroups(super::object::subscription::Groups),
            #[prost(message, tag = "2")]
            BlockAdd(super::block::Add),
            #[prost(message, tag = "3")]
            BlockDelete(super::block::Delete),
            #[prost(message, tag = "4")]
            FilesUpload(super::block::FilesUpload),
            #[prost(message, tag = "5")]
            MarksInfo(super::block::MarksInfo),
            #[prost(message, tag = "6")]
            BlockSetFields(super::block::set::Fields),
            #[prost(message, tag = "7")]
            BlockSetChildrenIds(super::block::set::ChildrenIds),
            #[prost(message, tag = "8")]
            BlockSetRestrictions(super::block::set::Restrictions),
            #[prost(message, tag = "9")]
            BlockSetBackgroundColor(super::block::set::BackgroundColor),
            #[prost(message, tag = "10")]
            BlockSetText(super::block::set::Text),
            #[prost(message, tag = "11")]
            BlockSetFile(super::block::set::File),
            #[prost(message, tag = "13")]
            BlockSetLink(super::block::set::Link),
            #[prost(message, tag = "14")]
            BlockSetBookmark(super::block::set::Bookmark),
            #[prost(message, tag = "15")]
            BlockSetAlign(super::block::set::Align),
            #[prost(message, tag = "17")]
            BlockSetDiv(super::block::set::Div),
            #[prost(message, tag = "21")]
            BlockSetRelation(super::block::set::Relation),
            #[prost(message, tag = "25")]
            BlockSetLatex(super::block::set::Latex),
            #[prost(message, tag = "36")]
            BlockSetVerticalAlign(super::block::set::VerticalAlign),
            #[prost(message, tag = "37")]
            BlockSetTableRow(super::block::set::TableRow),
            #[prost(message, tag = "40")]
            BlockSetWidget(super::block::set::Widget),
            #[prost(message, tag = "19")]
            BlockDataviewViewSet(super::block::dataview::ViewSet),
            #[prost(message, tag = "20")]
            BlockDataviewViewDelete(super::block::dataview::ViewDelete),
            #[prost(message, tag = "29")]
            BlockDataviewViewOrder(super::block::dataview::ViewOrder),
            /// deprecated, source is no longer used
            #[prost(message, tag = "35")]
            BlockDataviewSourceSet(super::block::dataview::SourceSet),
            #[prost(message, tag = "38")]
            BlockDataViewGroupOrderUpdate(super::block::dataview::GroupOrderUpdate),
            #[prost(message, tag = "39")]
            BlockDataViewObjectOrderUpdate(super::block::dataview::ObjectOrderUpdate),
            #[prost(message, tag = "124")]
            BlockDataviewRelationDelete(super::block::dataview::RelationDelete),
            #[prost(message, tag = "123")]
            BlockDataviewRelationSet(super::block::dataview::RelationSet),
            #[prost(message, tag = "125")]
            BlockDataviewViewUpdate(super::block::dataview::ViewUpdate),
            #[prost(message, tag = "126")]
            BlockDataviewTargetObjectIdSet(super::block::dataview::TargetObjectIdSet),
            #[prost(message, tag = "127")]
            BlockDataviewIsCollectionSet(super::block::dataview::IsCollectionSet),
            /// deprecated
            #[prost(message, tag = "24")]
            BlockDataviewOldRelationDelete(super::block::dataview::OldRelationDelete),
            /// deprecated
            #[prost(message, tag = "23")]
            BlockDataviewOldRelationSet(super::block::dataview::OldRelationSet),
            #[prost(message, tag = "31")]
            UserBlockJoin(super::user::block::Join),
            #[prost(message, tag = "32")]
            UserBlockLeft(super::user::block::Left),
            #[prost(message, tag = "33")]
            UserBlockSelectRange(super::user::block::SelectRange),
            #[prost(message, tag = "34")]
            UserBlockTextRange(super::user::block::TextRange),
            #[prost(message, tag = "100")]
            Ping(super::Ping),
            #[prost(message, tag = "101")]
            ProcessNew(super::process::New),
            #[prost(message, tag = "102")]
            ProcessUpdate(super::process::Update),
            #[prost(message, tag = "103")]
            ProcessDone(super::process::Done),
            #[prost(message, tag = "110")]
            ThreadStatus(super::status::Thread),
            #[prost(message, tag = "111")]
            FileLimitReached(super::file::LimitReached),
            #[prost(message, tag = "112")]
            FileSpaceUsage(super::file::SpaceUsage),
            #[prost(message, tag = "113")]
            FileLocalUsage(super::file::LocalUsage),
            #[prost(message, tag = "118")]
            FileLimitUpdated(super::file::LimitUpdated),
            #[prost(message, tag = "114")]
            NotificationSend(super::notification::Send),
            #[prost(message, tag = "115")]
            NotificationUpdate(super::notification::Update),
            #[prost(message, tag = "116")]
            PayloadBroadcast(super::payload::Broadcast),
            #[prost(message, tag = "117")]
            MembershipUpdate(super::membership::Update),
            #[prost(message, tag = "119")]
            SpaceSyncStatusUpdate(super::space::sync_status::Update),
            #[prost(message, tag = "122")]
            SpaceAutoWidgetAdded(super::space::AutoWidgetAdded),
            #[prost(message, tag = "120")]
            P2pStatusUpdate(super::p2p_status::Update),
            #[prost(message, tag = "121")]
            ImportFinish(super::import::Finish),
            #[prost(message, tag = "128")]
            ChatAdd(super::chat::Add),
            #[prost(message, tag = "129")]
            ChatUpdate(super::chat::Update),
            #[prost(message, tag = "130")]
            ChatUpdateReactions(super::chat::UpdateReactions),
            /// received to update per-message read status (if needed to highlight the unread messages in the UI)
            #[prost(message, tag = "134")]
            ChatUpdateMessageReadStatus(super::chat::UpdateMessageReadStatus),
            /// received to update per-message mention read status (if needed to highlight the unread mentions in the UI)
            #[prost(message, tag = "135")]
            ChatUpdateMentionReadStatus(super::chat::UpdateMentionReadStatus),
            #[prost(message, tag = "131")]
            ChatDelete(super::chat::Delete),
            /// in case new unread messages received or chat state changed (e.g. message read on another device)
            #[prost(message, tag = "133")]
            ChatStateUpdate(super::chat::UpdateState),
        }
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Chat {}
    /// Nested message and enum types in `Chat`.
    pub mod chat {
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Add {
            #[prost(string, tag = "1")]
            pub id: ::prost::alloc::string::String,
            #[prost(string, tag = "2")]
            pub order_id: ::prost::alloc::string::String,
            #[prost(string, tag = "6")]
            pub after_order_id: ::prost::alloc::string::String,
            #[prost(message, optional, tag = "3")]
            pub message: ::core::option::Option<
                crate::anytype_proto::anytype_model::ChatMessage,
            >,
            #[prost(string, repeated, tag = "4")]
            pub sub_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            #[prost(message, repeated, tag = "5")]
            pub dependencies: ::prost::alloc::vec::Vec<::prost_types::Struct>,
        }
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Delete {
            #[prost(string, tag = "1")]
            pub id: ::prost::alloc::string::String,
            #[prost(string, repeated, tag = "2")]
            pub sub_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        }
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Update {
            #[prost(string, tag = "1")]
            pub id: ::prost::alloc::string::String,
            #[prost(message, optional, tag = "2")]
            pub message: ::core::option::Option<
                crate::anytype_proto::anytype_model::ChatMessage,
            >,
            #[prost(string, repeated, tag = "3")]
            pub sub_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        }
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct UpdateReactions {
            #[prost(string, tag = "1")]
            pub id: ::prost::alloc::string::String,
            #[prost(message, optional, tag = "2")]
            pub reactions: ::core::option::Option<
                crate::anytype_proto::anytype_model::chat_message::Reactions,
            >,
            #[prost(string, repeated, tag = "3")]
            pub sub_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        }
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct UpdateMessageReadStatus {
            #[prost(string, repeated, tag = "1")]
            pub ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            #[prost(bool, tag = "2")]
            pub is_read: bool,
            #[prost(string, repeated, tag = "3")]
            pub sub_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        }
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct UpdateMentionReadStatus {
            #[prost(string, repeated, tag = "1")]
            pub ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            #[prost(bool, tag = "2")]
            pub is_read: bool,
            #[prost(string, repeated, tag = "3")]
            pub sub_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        }
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct UpdateState {
            #[prost(message, optional, tag = "1")]
            pub state: ::core::option::Option<
                crate::anytype_proto::anytype_model::ChatState,
            >,
            #[prost(string, repeated, tag = "2")]
            pub sub_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        }
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Account {}
    /// Nested message and enum types in `Account`.
    pub mod account {
        /// *
        /// Message, that will be sent to the front on each account found after an AccountRecoverRequest
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Show {
            /// Number of an account in an all found accounts list
            #[prost(int32, tag = "1")]
            pub index: i32,
            /// An Account, that has been found for the mnemonic
            #[prost(message, optional, tag = "2")]
            pub account: ::core::option::Option<
                crate::anytype_proto::anytype_model::Account,
            >,
        }
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Details {
            #[prost(string, tag = "1")]
            pub profile_id: ::prost::alloc::string::String,
            #[prost(message, optional, tag = "2")]
            pub details: ::core::option::Option<::prost_types::Struct>,
        }
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct Config {}
        /// Nested message and enum types in `Config`.
        pub mod config {
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Update {
                #[prost(message, optional, tag = "1")]
                pub config: ::core::option::Option<
                    crate::anytype_proto::anytype_model::account::Config,
                >,
                #[prost(message, optional, tag = "2")]
                pub status: ::core::option::Option<
                    crate::anytype_proto::anytype_model::account::Status,
                >,
            }
        }
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Update {
            #[prost(message, optional, tag = "1")]
            pub config: ::core::option::Option<
                crate::anytype_proto::anytype_model::account::Config,
            >,
            #[prost(message, optional, tag = "2")]
            pub status: ::core::option::Option<
                crate::anytype_proto::anytype_model::account::Status,
            >,
        }
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct LinkChallenge {
            #[prost(string, tag = "1")]
            pub challenge: ::prost::alloc::string::String,
            #[prost(message, optional, tag = "2")]
            pub client_info: ::core::option::Option<link_challenge::ClientInfo>,
            #[prost(
                enumeration = "crate::anytype_proto::anytype_model::account::auth::LocalApiScope",
                tag = "3"
            )]
            pub scope: i32,
        }
        /// Nested message and enum types in `LinkChallenge`.
        pub mod link_challenge {
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct ClientInfo {
                #[prost(string, tag = "1")]
                pub process_name: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub process_path: ::prost::alloc::string::String,
                #[prost(bool, tag = "3")]
                pub signature_verified: bool,
            }
        }
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct LinkChallengeHide {
            /// verify code before hiding to protect from MITM attacks
            #[prost(string, tag = "1")]
            pub challenge: ::prost::alloc::string::String,
        }
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Object {}
    /// Nested message and enum types in `Object`.
    pub mod object {
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct Details {}
        /// Nested message and enum types in `Details`.
        pub mod details {
            /// Amend (i.e. add a new key-value pair or update an existing key-value pair) existing state
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Amend {
                /// context objectId
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                /// slice of changed key-values
                #[prost(message, repeated, tag = "2")]
                pub details: ::prost::alloc::vec::Vec<amend::KeyValue>,
                #[prost(string, repeated, tag = "3")]
                pub sub_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            }
            /// Nested message and enum types in `Amend`.
            pub mod amend {
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct KeyValue {
                    #[prost(string, tag = "1")]
                    pub key: ::prost::alloc::string::String,
                    /// should not be null
                    #[prost(message, optional, tag = "2")]
                    pub value: ::core::option::Option<::prost_types::Value>,
                }
            }
            /// Overwrite current state
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Set {
                /// context objectId
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                /// can not be a partial state. Should replace client details state
                #[prost(message, optional, tag = "2")]
                pub details: ::core::option::Option<::prost_types::Struct>,
                #[prost(string, repeated, tag = "3")]
                pub sub_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            }
            /// Unset existing detail keys
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Unset {
                /// context objectId
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                #[prost(string, repeated, tag = "2")]
                pub keys: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                #[prost(string, repeated, tag = "3")]
                pub sub_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            }
        }
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct Subscription {}
        /// Nested message and enum types in `Subscription`.
        pub mod subscription {
            /// Adds new document to subscriptions
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Add {
                /// object id
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                /// id of previous doc in order, empty means first
                #[prost(string, tag = "2")]
                pub after_id: ::prost::alloc::string::String,
                /// subscription id
                #[prost(string, tag = "3")]
                pub sub_id: ::prost::alloc::string::String,
            }
            /// Removes document from subscription
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Remove {
                /// object id
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                /// subscription id
                #[prost(string, tag = "2")]
                pub sub_id: ::prost::alloc::string::String,
            }
            /// Indicates new position of document
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Position {
                /// object id
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                /// id of previous doc in order, empty means first
                #[prost(string, tag = "2")]
                pub after_id: ::prost::alloc::string::String,
                /// subscription id
                #[prost(string, tag = "3")]
                pub sub_id: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Counters {
                /// total available records
                #[prost(int64, tag = "1")]
                pub total: i64,
                /// how many records available after
                #[prost(int64, tag = "2")]
                pub next_count: i64,
                /// how many records available before
                #[prost(int64, tag = "3")]
                pub prev_count: i64,
                /// subscription id
                #[prost(string, tag = "4")]
                pub sub_id: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Groups {
                #[prost(string, tag = "1")]
                pub sub_id: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "2")]
                pub group: ::core::option::Option<
                    crate::anytype_proto::anytype_model::block::content::dataview::Group,
                >,
                #[prost(bool, tag = "3")]
                pub remove: bool,
            }
        }
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct Relations {}
        /// Nested message and enum types in `Relations`.
        pub mod relations {
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Amend {
                /// context objectId
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                #[prost(message, repeated, tag = "2")]
                pub relation_links: ::prost::alloc::vec::Vec<
                    crate::anytype_proto::anytype_model::RelationLink,
                >,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Remove {
                /// context objectId
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                #[prost(string, repeated, tag = "2")]
                pub relation_keys: ::prost::alloc::vec::Vec<
                    ::prost::alloc::string::String,
                >,
            }
        }
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Remove {
            /// notifies that objects were removed
            #[prost(string, repeated, tag = "1")]
            pub ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        }
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct Restrictions {}
        /// Nested message and enum types in `Restrictions`.
        pub mod restrictions {
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Set {
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "2")]
                pub restrictions: ::core::option::Option<
                    crate::anytype_proto::anytype_model::Restrictions,
                >,
            }
        }
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Close {
            #[prost(string, tag = "1")]
            pub id: ::prost::alloc::string::String,
        }
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Block {}
    /// Nested message and enum types in `Block`.
    pub mod block {
        ///
        /// Event to show internal blocks on a client.
        /// Example Scenarios
        /// A. Block Creation
        /// 1. Block A have been created on a client C1
        /// 2. Client C2 receives Event.Block.Add(Block A), Event.Block.Update(Page.children)
        /// B. Partial block load
        /// 1. Client C1 opens Page1, that contains, for example, 133 blocks.
        /// 2. M -> F: ShowFullScreen(Root, blocks1-50)
        /// 3. M -> F: Block.Add(blocks51-100)
        /// 3. M -> F: Block.Add(blocks101-133)
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Add {
            /// id -> block
            #[prost(message, repeated, tag = "1")]
            pub blocks: ::prost::alloc::vec::Vec<
                crate::anytype_proto::anytype_model::Block,
            >,
        }
        /// *
        /// Middleware to front end event message, that will be sent on one of this scenarios:
        /// Precondition: user A opened a block
        /// 1. User A drops a set of files/pictures/videos
        /// 2. User A creates a MediaBlock and drops a single media, that corresponds to its type.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct FilesUpload {
            /// if empty => create new blocks
            #[prost(string, tag = "1")]
            pub block_id: ::prost::alloc::string::String,
            /// filepaths to the files
            #[prost(string, repeated, tag = "2")]
            pub file_path: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        }
        ///
        ///
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Delete {
            #[prost(string, repeated, tag = "1")]
            pub block_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        }
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct MarksInfo {
            #[prost(
                enumeration = "crate::anytype_proto::anytype_model::block::content::text::mark::Type",
                repeated,
                tag = "1"
            )]
            pub marks_in_range: ::prost::alloc::vec::Vec<i32>,
        }
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct Set {}
        /// Nested message and enum types in `Set`.
        pub mod set {
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Relation {
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "2")]
                pub key: ::core::option::Option<relation::Key>,
            }
            /// Nested message and enum types in `Relation`.
            pub mod relation {
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct Key {
                    #[prost(string, tag = "1")]
                    pub value: ::prost::alloc::string::String,
                }
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Fields {
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "2")]
                pub fields: ::core::option::Option<::prost_types::Struct>,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct ChildrenIds {
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                #[prost(string, repeated, tag = "2")]
                pub children_ids: ::prost::alloc::vec::Vec<
                    ::prost::alloc::string::String,
                >,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Restrictions {
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "2")]
                pub restrictions: ::core::option::Option<
                    crate::anytype_proto::anytype_model::block::Restrictions,
                >,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct BackgroundColor {
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub background_color: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Align {
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                #[prost(
                    enumeration = "crate::anytype_proto::anytype_model::block::Align",
                    tag = "2"
                )]
                pub align: i32,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct VerticalAlign {
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                #[prost(
                    enumeration = "crate::anytype_proto::anytype_model::block::VerticalAlign",
                    tag = "2"
                )]
                pub vertical_align: i32,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Text {
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "2")]
                pub text: ::core::option::Option<text::Text>,
                #[prost(message, optional, tag = "3")]
                pub style: ::core::option::Option<text::Style>,
                #[prost(message, optional, tag = "4")]
                pub marks: ::core::option::Option<text::Marks>,
                #[prost(message, optional, tag = "5")]
                pub checked: ::core::option::Option<text::Checked>,
                #[prost(message, optional, tag = "6")]
                pub color: ::core::option::Option<text::Color>,
                #[prost(message, optional, tag = "7")]
                pub icon_emoji: ::core::option::Option<text::IconEmoji>,
                #[prost(message, optional, tag = "8")]
                pub icon_image: ::core::option::Option<text::IconImage>,
            }
            /// Nested message and enum types in `Text`.
            pub mod text {
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct Text {
                    #[prost(string, tag = "1")]
                    pub value: ::prost::alloc::string::String,
                }
                #[derive(Clone, Copy, PartialEq, ::prost::Message)]
                pub struct Style {
                    #[prost(
                        enumeration = "crate::anytype_proto::anytype_model::block::content::text::Style",
                        tag = "1"
                    )]
                    pub value: i32,
                }
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct Marks {
                    #[prost(message, optional, tag = "1")]
                    pub value: ::core::option::Option<
                        crate::anytype_proto::anytype_model::block::content::text::Marks,
                    >,
                }
                #[derive(Clone, Copy, PartialEq, ::prost::Message)]
                pub struct Checked {
                    #[prost(bool, tag = "1")]
                    pub value: bool,
                }
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct Color {
                    #[prost(string, tag = "1")]
                    pub value: ::prost::alloc::string::String,
                }
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct IconEmoji {
                    #[prost(string, tag = "1")]
                    pub value: ::prost::alloc::string::String,
                }
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct IconImage {
                    #[prost(string, tag = "1")]
                    pub value: ::prost::alloc::string::String,
                }
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Latex {
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "2")]
                pub text: ::core::option::Option<latex::Text>,
                #[prost(message, optional, tag = "3")]
                pub processor: ::core::option::Option<latex::Processor>,
            }
            /// Nested message and enum types in `Latex`.
            pub mod latex {
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct Text {
                    #[prost(string, tag = "1")]
                    pub value: ::prost::alloc::string::String,
                }
                #[derive(Clone, Copy, PartialEq, ::prost::Message)]
                pub struct Processor {
                    #[prost(
                        enumeration = "crate::anytype_proto::anytype_model::block::content::latex::Processor",
                        tag = "1"
                    )]
                    pub value: i32,
                }
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Div {
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "2")]
                pub style: ::core::option::Option<div::Style>,
            }
            /// Nested message and enum types in `Div`.
            pub mod div {
                #[derive(Clone, Copy, PartialEq, ::prost::Message)]
                pub struct Style {
                    #[prost(
                        enumeration = "crate::anytype_proto::anytype_model::block::content::div::Style",
                        tag = "1"
                    )]
                    pub value: i32,
                }
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct File {
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "2")]
                pub r#type: ::core::option::Option<file::Type>,
                #[prost(message, optional, tag = "3")]
                pub state: ::core::option::Option<file::State>,
                #[prost(message, optional, tag = "4")]
                pub mime: ::core::option::Option<file::Mime>,
                #[prost(message, optional, tag = "5")]
                pub hash: ::core::option::Option<file::Hash>,
                #[prost(message, optional, tag = "6")]
                pub name: ::core::option::Option<file::Name>,
                #[prost(message, optional, tag = "7")]
                pub size: ::core::option::Option<file::Size>,
                #[prost(message, optional, tag = "8")]
                pub style: ::core::option::Option<file::Style>,
                #[prost(message, optional, tag = "9")]
                pub target_object_id: ::core::option::Option<file::TargetObjectId>,
            }
            /// Nested message and enum types in `File`.
            pub mod file {
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct Name {
                    #[prost(string, tag = "1")]
                    pub value: ::prost::alloc::string::String,
                }
                #[derive(Clone, Copy, PartialEq, ::prost::Message)]
                pub struct Width {
                    #[prost(int32, tag = "1")]
                    pub value: i32,
                }
                #[derive(Clone, Copy, PartialEq, ::prost::Message)]
                pub struct State {
                    #[prost(
                        enumeration = "crate::anytype_proto::anytype_model::block::content::file::State",
                        tag = "1"
                    )]
                    pub value: i32,
                }
                #[derive(Clone, Copy, PartialEq, ::prost::Message)]
                pub struct Type {
                    #[prost(
                        enumeration = "crate::anytype_proto::anytype_model::block::content::file::Type",
                        tag = "1"
                    )]
                    pub value: i32,
                }
                #[derive(Clone, Copy, PartialEq, ::prost::Message)]
                pub struct Style {
                    #[prost(
                        enumeration = "crate::anytype_proto::anytype_model::block::content::file::Style",
                        tag = "1"
                    )]
                    pub value: i32,
                }
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct Hash {
                    #[prost(string, tag = "1")]
                    pub value: ::prost::alloc::string::String,
                }
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct Mime {
                    #[prost(string, tag = "1")]
                    pub value: ::prost::alloc::string::String,
                }
                #[derive(Clone, Copy, PartialEq, ::prost::Message)]
                pub struct Size {
                    #[prost(int64, tag = "1")]
                    pub value: i64,
                }
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct TargetObjectId {
                    #[prost(string, tag = "1")]
                    pub value: ::prost::alloc::string::String,
                }
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Link {
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "2")]
                pub target_block_id: ::core::option::Option<link::TargetBlockId>,
                #[prost(message, optional, tag = "3")]
                pub style: ::core::option::Option<link::Style>,
                #[prost(message, optional, tag = "4")]
                pub fields: ::core::option::Option<link::Fields>,
                #[prost(message, optional, tag = "5")]
                pub icon_size: ::core::option::Option<link::IconSize>,
                #[prost(message, optional, tag = "6")]
                pub card_style: ::core::option::Option<link::CardStyle>,
                #[prost(message, optional, tag = "7")]
                pub description: ::core::option::Option<link::Description>,
                #[prost(message, optional, tag = "8")]
                pub relations: ::core::option::Option<link::Relations>,
            }
            /// Nested message and enum types in `Link`.
            pub mod link {
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct TargetBlockId {
                    #[prost(string, tag = "1")]
                    pub value: ::prost::alloc::string::String,
                }
                #[derive(Clone, Copy, PartialEq, ::prost::Message)]
                pub struct Style {
                    #[prost(
                        enumeration = "crate::anytype_proto::anytype_model::block::content::link::Style",
                        tag = "1"
                    )]
                    pub value: i32,
                }
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct Fields {
                    #[prost(message, optional, tag = "1")]
                    pub value: ::core::option::Option<::prost_types::Struct>,
                }
                #[derive(Clone, Copy, PartialEq, ::prost::Message)]
                pub struct IconSize {
                    #[prost(
                        enumeration = "crate::anytype_proto::anytype_model::block::content::link::IconSize",
                        tag = "1"
                    )]
                    pub value: i32,
                }
                #[derive(Clone, Copy, PartialEq, ::prost::Message)]
                pub struct CardStyle {
                    #[prost(
                        enumeration = "crate::anytype_proto::anytype_model::block::content::link::CardStyle",
                        tag = "1"
                    )]
                    pub value: i32,
                }
                #[derive(Clone, Copy, PartialEq, ::prost::Message)]
                pub struct Description {
                    #[prost(
                        enumeration = "crate::anytype_proto::anytype_model::block::content::link::Description",
                        tag = "1"
                    )]
                    pub value: i32,
                }
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct Relations {
                    #[prost(string, repeated, tag = "1")]
                    pub value: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                }
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Bookmark {
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "2")]
                pub url: ::core::option::Option<bookmark::Url>,
                #[prost(message, optional, tag = "3")]
                pub title: ::core::option::Option<bookmark::Title>,
                #[prost(message, optional, tag = "4")]
                pub description: ::core::option::Option<bookmark::Description>,
                #[prost(message, optional, tag = "5")]
                pub image_hash: ::core::option::Option<bookmark::ImageHash>,
                #[prost(message, optional, tag = "6")]
                pub favicon_hash: ::core::option::Option<bookmark::FaviconHash>,
                #[prost(message, optional, tag = "7")]
                pub r#type: ::core::option::Option<bookmark::Type>,
                #[prost(message, optional, tag = "8")]
                pub target_object_id: ::core::option::Option<bookmark::TargetObjectId>,
                #[prost(message, optional, tag = "9")]
                pub state: ::core::option::Option<bookmark::State>,
            }
            /// Nested message and enum types in `Bookmark`.
            pub mod bookmark {
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct Url {
                    #[prost(string, tag = "1")]
                    pub value: ::prost::alloc::string::String,
                }
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct Title {
                    #[prost(string, tag = "1")]
                    pub value: ::prost::alloc::string::String,
                }
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct Description {
                    #[prost(string, tag = "1")]
                    pub value: ::prost::alloc::string::String,
                }
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct ImageHash {
                    #[prost(string, tag = "1")]
                    pub value: ::prost::alloc::string::String,
                }
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct FaviconHash {
                    #[prost(string, tag = "1")]
                    pub value: ::prost::alloc::string::String,
                }
                #[derive(Clone, Copy, PartialEq, ::prost::Message)]
                pub struct Type {
                    #[prost(
                        enumeration = "crate::anytype_proto::anytype_model::link_preview::Type",
                        tag = "1"
                    )]
                    pub value: i32,
                }
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct TargetObjectId {
                    #[prost(string, tag = "1")]
                    pub value: ::prost::alloc::string::String,
                }
                #[derive(Clone, Copy, PartialEq, ::prost::Message)]
                pub struct State {
                    #[prost(
                        enumeration = "crate::anytype_proto::anytype_model::block::content::bookmark::State",
                        tag = "1"
                    )]
                    pub value: i32,
                }
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct TableRow {
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "2")]
                pub is_header: ::core::option::Option<table_row::IsHeader>,
            }
            /// Nested message and enum types in `TableRow`.
            pub mod table_row {
                #[derive(Clone, Copy, PartialEq, ::prost::Message)]
                pub struct IsHeader {
                    #[prost(bool, tag = "1")]
                    pub value: bool,
                }
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Widget {
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "2")]
                pub layout: ::core::option::Option<widget::Layout>,
                #[prost(message, optional, tag = "3")]
                pub limit: ::core::option::Option<widget::Limit>,
                #[prost(message, optional, tag = "4")]
                pub view_id: ::core::option::Option<widget::ViewId>,
            }
            /// Nested message and enum types in `Widget`.
            pub mod widget {
                #[derive(Clone, Copy, PartialEq, ::prost::Message)]
                pub struct Layout {
                    #[prost(
                        enumeration = "crate::anytype_proto::anytype_model::block::content::widget::Layout",
                        tag = "1"
                    )]
                    pub value: i32,
                }
                #[derive(Clone, Copy, PartialEq, ::prost::Message)]
                pub struct Limit {
                    #[prost(int32, tag = "1")]
                    pub value: i32,
                }
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct ViewId {
                    #[prost(string, tag = "1")]
                    pub value: ::prost::alloc::string::String,
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct Fill {}
        /// Nested message and enum types in `Fill`.
        pub mod fill {
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Details {
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "2")]
                pub details: ::core::option::Option<::prost_types::Struct>,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct DatabaseRecords {
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                #[prost(message, repeated, tag = "2")]
                pub records: ::prost::alloc::vec::Vec<::prost_types::Struct>,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Fields {
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "2")]
                pub fields: ::core::option::Option<::prost_types::Struct>,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct ChildrenIds {
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                #[prost(string, repeated, tag = "2")]
                pub children_ids: ::prost::alloc::vec::Vec<
                    ::prost::alloc::string::String,
                >,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Restrictions {
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "2")]
                pub restrictions: ::core::option::Option<
                    crate::anytype_proto::anytype_model::block::Restrictions,
                >,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct BackgroundColor {
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub background_color: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Align {
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                #[prost(
                    enumeration = "crate::anytype_proto::anytype_model::block::Align",
                    tag = "2"
                )]
                pub align: i32,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Text {
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "2")]
                pub text: ::core::option::Option<text::Text>,
                #[prost(message, optional, tag = "3")]
                pub style: ::core::option::Option<text::Style>,
                #[prost(message, optional, tag = "4")]
                pub marks: ::core::option::Option<text::Marks>,
                #[prost(message, optional, tag = "5")]
                pub checked: ::core::option::Option<text::Checked>,
                #[prost(message, optional, tag = "6")]
                pub color: ::core::option::Option<text::Color>,
            }
            /// Nested message and enum types in `Text`.
            pub mod text {
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct Text {
                    #[prost(string, tag = "1")]
                    pub value: ::prost::alloc::string::String,
                }
                #[derive(Clone, Copy, PartialEq, ::prost::Message)]
                pub struct Style {
                    #[prost(
                        enumeration = "crate::anytype_proto::anytype_model::block::content::text::Style",
                        tag = "1"
                    )]
                    pub value: i32,
                }
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct Marks {
                    #[prost(message, optional, tag = "1")]
                    pub value: ::core::option::Option<
                        crate::anytype_proto::anytype_model::block::content::text::Marks,
                    >,
                }
                #[derive(Clone, Copy, PartialEq, ::prost::Message)]
                pub struct Checked {
                    #[prost(bool, tag = "1")]
                    pub value: bool,
                }
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct Color {
                    #[prost(string, tag = "1")]
                    pub value: ::prost::alloc::string::String,
                }
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Div {
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "2")]
                pub style: ::core::option::Option<div::Style>,
            }
            /// Nested message and enum types in `Div`.
            pub mod div {
                #[derive(Clone, Copy, PartialEq, ::prost::Message)]
                pub struct Style {
                    #[prost(
                        enumeration = "crate::anytype_proto::anytype_model::block::content::div::Style",
                        tag = "1"
                    )]
                    pub value: i32,
                }
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct File {
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "2")]
                pub r#type: ::core::option::Option<file::Type>,
                #[prost(message, optional, tag = "3")]
                pub state: ::core::option::Option<file::State>,
                #[prost(message, optional, tag = "4")]
                pub mime: ::core::option::Option<file::Mime>,
                #[prost(message, optional, tag = "5")]
                pub hash: ::core::option::Option<file::Hash>,
                #[prost(message, optional, tag = "6")]
                pub name: ::core::option::Option<file::Name>,
                #[prost(message, optional, tag = "7")]
                pub size: ::core::option::Option<file::Size>,
                #[prost(message, optional, tag = "8")]
                pub style: ::core::option::Option<file::Style>,
            }
            /// Nested message and enum types in `File`.
            pub mod file {
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct Name {
                    #[prost(string, tag = "1")]
                    pub value: ::prost::alloc::string::String,
                }
                #[derive(Clone, Copy, PartialEq, ::prost::Message)]
                pub struct Width {
                    #[prost(int32, tag = "1")]
                    pub value: i32,
                }
                #[derive(Clone, Copy, PartialEq, ::prost::Message)]
                pub struct State {
                    #[prost(
                        enumeration = "crate::anytype_proto::anytype_model::block::content::file::State",
                        tag = "1"
                    )]
                    pub value: i32,
                }
                #[derive(Clone, Copy, PartialEq, ::prost::Message)]
                pub struct Type {
                    #[prost(
                        enumeration = "crate::anytype_proto::anytype_model::block::content::file::Type",
                        tag = "1"
                    )]
                    pub value: i32,
                }
                #[derive(Clone, Copy, PartialEq, ::prost::Message)]
                pub struct Style {
                    #[prost(
                        enumeration = "crate::anytype_proto::anytype_model::block::content::file::Style",
                        tag = "1"
                    )]
                    pub value: i32,
                }
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct Hash {
                    #[prost(string, tag = "1")]
                    pub value: ::prost::alloc::string::String,
                }
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct Mime {
                    #[prost(string, tag = "1")]
                    pub value: ::prost::alloc::string::String,
                }
                #[derive(Clone, Copy, PartialEq, ::prost::Message)]
                pub struct Size {
                    #[prost(int64, tag = "1")]
                    pub value: i64,
                }
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Link {
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "2")]
                pub target_block_id: ::core::option::Option<link::TargetBlockId>,
                #[prost(message, optional, tag = "3")]
                pub style: ::core::option::Option<link::Style>,
                #[prost(message, optional, tag = "4")]
                pub fields: ::core::option::Option<link::Fields>,
            }
            /// Nested message and enum types in `Link`.
            pub mod link {
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct TargetBlockId {
                    #[prost(string, tag = "1")]
                    pub value: ::prost::alloc::string::String,
                }
                #[derive(Clone, Copy, PartialEq, ::prost::Message)]
                pub struct Style {
                    #[prost(
                        enumeration = "crate::anytype_proto::anytype_model::block::content::link::Style",
                        tag = "1"
                    )]
                    pub value: i32,
                }
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct Fields {
                    #[prost(message, optional, tag = "1")]
                    pub value: ::core::option::Option<::prost_types::Struct>,
                }
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Bookmark {
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "2")]
                pub url: ::core::option::Option<bookmark::Url>,
                #[prost(message, optional, tag = "3")]
                pub title: ::core::option::Option<bookmark::Title>,
                #[prost(message, optional, tag = "4")]
                pub description: ::core::option::Option<bookmark::Description>,
                #[prost(message, optional, tag = "5")]
                pub image_hash: ::core::option::Option<bookmark::ImageHash>,
                #[prost(message, optional, tag = "6")]
                pub favicon_hash: ::core::option::Option<bookmark::FaviconHash>,
                #[prost(message, optional, tag = "7")]
                pub r#type: ::core::option::Option<bookmark::Type>,
                #[prost(message, optional, tag = "8")]
                pub target_object_id: ::core::option::Option<bookmark::TargetObjectId>,
            }
            /// Nested message and enum types in `Bookmark`.
            pub mod bookmark {
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct Url {
                    #[prost(string, tag = "1")]
                    pub value: ::prost::alloc::string::String,
                }
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct Title {
                    #[prost(string, tag = "1")]
                    pub value: ::prost::alloc::string::String,
                }
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct Description {
                    #[prost(string, tag = "1")]
                    pub value: ::prost::alloc::string::String,
                }
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct ImageHash {
                    #[prost(string, tag = "1")]
                    pub value: ::prost::alloc::string::String,
                }
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct FaviconHash {
                    #[prost(string, tag = "1")]
                    pub value: ::prost::alloc::string::String,
                }
                #[derive(Clone, Copy, PartialEq, ::prost::Message)]
                pub struct Type {
                    #[prost(
                        enumeration = "crate::anytype_proto::anytype_model::link_preview::Type",
                        tag = "1"
                    )]
                    pub value: i32,
                }
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct TargetObjectId {
                    #[prost(string, tag = "1")]
                    pub value: ::prost::alloc::string::String,
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct Dataview {}
        /// Nested message and enum types in `Dataview`.
        pub mod dataview {
            /// sent when the view have been changed or added
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct ViewSet {
                /// dataview block's id
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                /// view id, client should double check this to make sure client doesn't switch the active view in the middle
                #[prost(string, tag = "2")]
                pub view_id: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "3")]
                pub view: ::core::option::Option<
                    crate::anytype_proto::anytype_model::block::content::dataview::View,
                >,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct ViewUpdate {
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub view_id: ::prost::alloc::string::String,
                #[prost(message, repeated, tag = "3")]
                pub filter: ::prost::alloc::vec::Vec<view_update::Filter>,
                #[prost(message, repeated, tag = "4")]
                pub relation: ::prost::alloc::vec::Vec<view_update::Relation>,
                #[prost(message, repeated, tag = "5")]
                pub sort: ::prost::alloc::vec::Vec<view_update::Sort>,
                #[prost(message, optional, tag = "6")]
                pub fields: ::core::option::Option<view_update::Fields>,
            }
            /// Nested message and enum types in `ViewUpdate`.
            pub mod view_update {
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct Fields {
                    #[prost(
                        enumeration = "crate::anytype_proto::anytype_model::block::content::dataview::view::Type",
                        tag = "1"
                    )]
                    pub r#type: i32,
                    #[prost(string, tag = "2")]
                    pub name: ::prost::alloc::string::String,
                    /// Relation used for cover in gallery
                    #[prost(string, tag = "3")]
                    pub cover_relation_key: ::prost::alloc::string::String,
                    /// Hide icon near name
                    #[prost(bool, tag = "4")]
                    pub hide_icon: bool,
                    /// Gallery card size
                    #[prost(
                        enumeration = "crate::anytype_proto::anytype_model::block::content::dataview::view::Size",
                        tag = "5"
                    )]
                    pub card_size: i32,
                    /// Image fits container
                    #[prost(bool, tag = "6")]
                    pub cover_fit: bool,
                    /// Group view by this relationKey
                    #[prost(string, tag = "7")]
                    pub group_relation_key: ::prost::alloc::string::String,
                    /// Enable backgrounds in groups
                    #[prost(bool, tag = "8")]
                    pub group_background_colors: bool,
                    /// Limit of objects shown in widget
                    #[prost(int32, tag = "9")]
                    pub page_limit: i32,
                    /// Id of template object set default for the view
                    #[prost(string, tag = "10")]
                    pub default_template_id: ::prost::alloc::string::String,
                    /// Default object type that is chosen for new object created within the view
                    #[prost(string, tag = "15")]
                    pub default_object_type_id: ::prost::alloc::string::String,
                }
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct Filter {
                    #[prost(oneof = "filter::Operation", tags = "1, 2, 3, 4")]
                    pub operation: ::core::option::Option<filter::Operation>,
                }
                /// Nested message and enum types in `Filter`.
                pub mod filter {
                    #[derive(Clone, PartialEq, ::prost::Message)]
                    pub struct Add {
                        #[prost(string, tag = "1")]
                        pub after_id: ::prost::alloc::string::String,
                        #[prost(message, repeated, tag = "2")]
                        pub items: ::prost::alloc::vec::Vec<
                            crate::anytype_proto::anytype_model::block::content::dataview::Filter,
                        >,
                    }
                    #[derive(Clone, PartialEq, ::prost::Message)]
                    pub struct Remove {
                        #[prost(string, repeated, tag = "1")]
                        pub ids: ::prost::alloc::vec::Vec<
                            ::prost::alloc::string::String,
                        >,
                    }
                    #[derive(Clone, PartialEq, ::prost::Message)]
                    pub struct Update {
                        #[prost(string, tag = "1")]
                        pub id: ::prost::alloc::string::String,
                        #[prost(message, optional, tag = "2")]
                        pub item: ::core::option::Option<
                            crate::anytype_proto::anytype_model::block::content::dataview::Filter,
                        >,
                    }
                    #[derive(Clone, PartialEq, ::prost::Message)]
                    pub struct Move {
                        #[prost(string, tag = "1")]
                        pub after_id: ::prost::alloc::string::String,
                        #[prost(string, repeated, tag = "2")]
                        pub ids: ::prost::alloc::vec::Vec<
                            ::prost::alloc::string::String,
                        >,
                    }
                    #[derive(Clone, PartialEq, ::prost::Oneof)]
                    pub enum Operation {
                        #[prost(message, tag = "1")]
                        Add(Add),
                        #[prost(message, tag = "2")]
                        Remove(Remove),
                        #[prost(message, tag = "3")]
                        Update(Update),
                        #[prost(message, tag = "4")]
                        Move(Move),
                    }
                }
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct Relation {
                    #[prost(oneof = "relation::Operation", tags = "1, 2, 3, 4")]
                    pub operation: ::core::option::Option<relation::Operation>,
                }
                /// Nested message and enum types in `Relation`.
                pub mod relation {
                    #[derive(Clone, PartialEq, ::prost::Message)]
                    pub struct Add {
                        #[prost(string, tag = "1")]
                        pub after_id: ::prost::alloc::string::String,
                        #[prost(message, repeated, tag = "2")]
                        pub items: ::prost::alloc::vec::Vec<
                            crate::anytype_proto::anytype_model::block::content::dataview::Relation,
                        >,
                    }
                    #[derive(Clone, PartialEq, ::prost::Message)]
                    pub struct Remove {
                        #[prost(string, repeated, tag = "1")]
                        pub ids: ::prost::alloc::vec::Vec<
                            ::prost::alloc::string::String,
                        >,
                    }
                    #[derive(Clone, PartialEq, ::prost::Message)]
                    pub struct Update {
                        #[prost(string, tag = "1")]
                        pub id: ::prost::alloc::string::String,
                        #[prost(message, optional, tag = "2")]
                        pub item: ::core::option::Option<
                            crate::anytype_proto::anytype_model::block::content::dataview::Relation,
                        >,
                    }
                    #[derive(Clone, PartialEq, ::prost::Message)]
                    pub struct Move {
                        #[prost(string, tag = "1")]
                        pub after_id: ::prost::alloc::string::String,
                        #[prost(string, repeated, tag = "2")]
                        pub ids: ::prost::alloc::vec::Vec<
                            ::prost::alloc::string::String,
                        >,
                    }
                    #[derive(Clone, PartialEq, ::prost::Oneof)]
                    pub enum Operation {
                        #[prost(message, tag = "1")]
                        Add(Add),
                        #[prost(message, tag = "2")]
                        Remove(Remove),
                        #[prost(message, tag = "3")]
                        Update(Update),
                        #[prost(message, tag = "4")]
                        Move(Move),
                    }
                }
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct Sort {
                    #[prost(oneof = "sort::Operation", tags = "1, 2, 3, 4")]
                    pub operation: ::core::option::Option<sort::Operation>,
                }
                /// Nested message and enum types in `Sort`.
                pub mod sort {
                    #[derive(Clone, PartialEq, ::prost::Message)]
                    pub struct Add {
                        #[prost(string, tag = "1")]
                        pub after_id: ::prost::alloc::string::String,
                        #[prost(message, repeated, tag = "2")]
                        pub items: ::prost::alloc::vec::Vec<
                            crate::anytype_proto::anytype_model::block::content::dataview::Sort,
                        >,
                    }
                    #[derive(Clone, PartialEq, ::prost::Message)]
                    pub struct Remove {
                        #[prost(string, repeated, tag = "1")]
                        pub ids: ::prost::alloc::vec::Vec<
                            ::prost::alloc::string::String,
                        >,
                    }
                    #[derive(Clone, PartialEq, ::prost::Message)]
                    pub struct Update {
                        #[prost(string, tag = "1")]
                        pub id: ::prost::alloc::string::String,
                        #[prost(message, optional, tag = "2")]
                        pub item: ::core::option::Option<
                            crate::anytype_proto::anytype_model::block::content::dataview::Sort,
                        >,
                    }
                    #[derive(Clone, PartialEq, ::prost::Message)]
                    pub struct Move {
                        #[prost(string, tag = "1")]
                        pub after_id: ::prost::alloc::string::String,
                        #[prost(string, repeated, tag = "2")]
                        pub ids: ::prost::alloc::vec::Vec<
                            ::prost::alloc::string::String,
                        >,
                    }
                    #[derive(Clone, PartialEq, ::prost::Oneof)]
                    pub enum Operation {
                        #[prost(message, tag = "1")]
                        Add(Add),
                        #[prost(message, tag = "2")]
                        Remove(Remove),
                        #[prost(message, tag = "3")]
                        Update(Update),
                        #[prost(message, tag = "4")]
                        Move(Move),
                    }
                }
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct ViewDelete {
                /// dataview block's id
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                /// view id to remove
                #[prost(string, tag = "2")]
                pub view_id: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct ViewOrder {
                /// dataview block's id
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                /// view ids in new order
                #[prost(string, repeated, tag = "2")]
                pub view_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct SourceSet {
                /// dataview block's id
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                #[prost(string, repeated, tag = "2")]
                pub source: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct OldRelationDelete {
                /// dataview block's id
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                /// relation key to remove
                #[prost(string, tag = "2")]
                pub relation_key: ::prost::alloc::string::String,
            }
            /// sent when the dataview relation has been changed or added
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct OldRelationSet {
                /// dataview block's id
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                /// relation key to update
                #[prost(string, tag = "2")]
                pub relation_key: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "3")]
                pub relation: ::core::option::Option<
                    crate::anytype_proto::anytype_model::Relation,
                >,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct RelationDelete {
                /// dataview block's id
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                /// relation key to remove
                #[prost(string, repeated, tag = "2")]
                pub relation_keys: ::prost::alloc::vec::Vec<
                    ::prost::alloc::string::String,
                >,
            }
            /// sent when the dataview relation has been changed or added
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct RelationSet {
                /// dataview block's id
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                /// relation id to update
                #[prost(message, repeated, tag = "2")]
                pub relation_links: ::prost::alloc::vec::Vec<
                    crate::anytype_proto::anytype_model::RelationLink,
                >,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct GroupOrderUpdate {
                /// dataview block's id
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "2")]
                pub group_order: ::core::option::Option<
                    crate::anytype_proto::anytype_model::block::content::dataview::GroupOrder,
                >,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct ObjectOrderUpdate {
                /// dataview block's id
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub view_id: ::prost::alloc::string::String,
                #[prost(string, tag = "3")]
                pub group_id: ::prost::alloc::string::String,
                #[prost(message, repeated, tag = "4")]
                pub slice_changes: ::prost::alloc::vec::Vec<SliceChange>,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct SliceChange {
                #[prost(enumeration = "SliceOperation", tag = "1")]
                pub op: i32,
                #[prost(string, repeated, tag = "2")]
                pub ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                #[prost(string, tag = "3")]
                pub after_id: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct TargetObjectIdSet {
                /// dataview block's id
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub target_object_id: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct IsCollectionSet {
                /// dataview block's id
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                #[prost(bool, tag = "2")]
                pub value: bool,
            }
            #[derive(
                Clone,
                Copy,
                Debug,
                PartialEq,
                Eq,
                Hash,
                PartialOrd,
                Ord,
                ::prost::Enumeration
            )]
            #[repr(i32)]
            pub enum SliceOperation {
                /// not used
                None = 0,
                Add = 1,
                Move = 2,
                Remove = 3,
                Replace = 4,
            }
            impl SliceOperation {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        Self::None => "SliceOperationNone",
                        Self::Add => "SliceOperationAdd",
                        Self::Move => "SliceOperationMove",
                        Self::Remove => "SliceOperationRemove",
                        Self::Replace => "SliceOperationReplace",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "SliceOperationNone" => Some(Self::None),
                        "SliceOperationAdd" => Some(Self::Add),
                        "SliceOperationMove" => Some(Self::Move),
                        "SliceOperationRemove" => Some(Self::Remove),
                        "SliceOperationReplace" => Some(Self::Replace),
                        _ => None,
                    }
                }
            }
        }
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct User {}
    /// Nested message and enum types in `User`.
    pub mod user {
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct Block {}
        /// Nested message and enum types in `Block`.
        pub mod block {
            /// *
            ///   Middleware to front end event message, that will be sent in this scenario:
            /// Precondition: user A opened a block
            /// 1. User B opens the same block
            /// 2. User A receives a message about p.1
            #[derive(Clone, Copy, PartialEq, ::prost::Message)]
            pub struct Join {
                /// Account of the user, that opened a block
                #[prost(message, optional, tag = "1")]
                pub account: ::core::option::Option<super::super::Account>,
            }
            /// *
            ///   Middleware to front end event message, that will be sent in this scenario:
            /// Precondition: user A and user B opened the same block
            /// 1. User B closes the block
            /// 2. User A receives a message about p.1
            #[derive(Clone, Copy, PartialEq, ::prost::Message)]
            pub struct Left {
                /// Account of the user, that left the block
                #[prost(message, optional, tag = "1")]
                pub account: ::core::option::Option<super::super::Account>,
            }
            /// *
            /// Middleware to front end event message, that will be sent in this scenario:
            /// Precondition: user A and user B opened the same block
            /// 1. User B sets cursor or selects a text region into a text block
            /// 2. User A receives a message about p.1
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct TextRange {
                /// Account of the user, that selected a text
                #[prost(message, optional, tag = "1")]
                pub account: ::core::option::Option<super::super::Account>,
                /// Id of the text block, that have a selection
                #[prost(string, tag = "2")]
                pub block_id: ::prost::alloc::string::String,
                /// Range of the selection
                #[prost(message, optional, tag = "3")]
                pub range: ::core::option::Option<
                    crate::anytype_proto::anytype_model::Range,
                >,
            }
            /// *
            /// Middleware to front end event message, that will be sent in this scenario:
            /// Precondition: user A and user B opened the same block
            /// 1. User B selects some inner blocks
            /// 2. User A receives a message about p.1
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct SelectRange {
                /// Account of the user, that selected blocks
                #[prost(message, optional, tag = "1")]
                pub account: ::core::option::Option<super::super::Account>,
                /// Ids of selected blocks.
                #[prost(string, repeated, tag = "2")]
                pub block_ids_array: ::prost::alloc::vec::Vec<
                    ::prost::alloc::string::String,
                >,
            }
        }
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Ping {
        #[prost(int32, tag = "1")]
        pub index: i32,
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Process {}
    /// Nested message and enum types in `Process`.
    pub mod process {
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct New {
            #[prost(message, optional, tag = "1")]
            pub process: ::core::option::Option<super::super::event_model::Process>,
        }
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Update {
            #[prost(message, optional, tag = "1")]
            pub process: ::core::option::Option<super::super::event_model::Process>,
        }
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Done {
            #[prost(message, optional, tag = "1")]
            pub process: ::core::option::Option<super::super::event_model::Process>,
        }
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Status {}
    /// Nested message and enum types in `Status`.
    pub mod status {
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Thread {
            #[prost(message, optional, tag = "1")]
            pub summary: ::core::option::Option<thread::Summary>,
            #[prost(message, optional, tag = "2")]
            pub cafe: ::core::option::Option<thread::Cafe>,
            #[prost(message, repeated, tag = "3")]
            pub accounts: ::prost::alloc::vec::Vec<thread::Account>,
        }
        /// Nested message and enum types in `Thread`.
        pub mod thread {
            #[derive(Clone, Copy, PartialEq, ::prost::Message)]
            pub struct Summary {
                #[prost(enumeration = "SyncStatus", tag = "1")]
                pub status: i32,
            }
            #[derive(Clone, Copy, PartialEq, ::prost::Message)]
            pub struct Cafe {
                #[prost(enumeration = "SyncStatus", tag = "1")]
                pub status: i32,
                #[prost(int64, tag = "2")]
                pub last_pulled: i64,
                #[prost(bool, tag = "3")]
                pub last_push_succeed: bool,
                #[prost(message, optional, tag = "4")]
                pub files: ::core::option::Option<cafe::PinStatus>,
            }
            /// Nested message and enum types in `Cafe`.
            pub mod cafe {
                #[derive(Clone, Copy, PartialEq, ::prost::Message)]
                pub struct PinStatus {
                    #[prost(int32, tag = "1")]
                    pub pinning: i32,
                    #[prost(int32, tag = "2")]
                    pub pinned: i32,
                    #[prost(int32, tag = "3")]
                    pub failed: i32,
                    #[prost(int64, tag = "4")]
                    pub updated: i64,
                }
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Account {
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub name: ::prost::alloc::string::String,
                #[prost(string, tag = "3")]
                pub image_hash: ::prost::alloc::string::String,
                #[prost(bool, tag = "4")]
                pub online: bool,
                #[prost(int64, tag = "5")]
                pub last_pulled: i64,
                #[prost(int64, tag = "6")]
                pub last_edited: i64,
                #[prost(message, repeated, tag = "7")]
                pub devices: ::prost::alloc::vec::Vec<Device>,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Device {
                #[prost(string, tag = "1")]
                pub name: ::prost::alloc::string::String,
                #[prost(bool, tag = "2")]
                pub online: bool,
                #[prost(int64, tag = "3")]
                pub last_pulled: i64,
                #[prost(int64, tag = "4")]
                pub last_edited: i64,
            }
            #[derive(
                Clone,
                Copy,
                Debug,
                PartialEq,
                Eq,
                Hash,
                PartialOrd,
                Ord,
                ::prost::Enumeration
            )]
            #[repr(i32)]
            pub enum SyncStatus {
                Unknown = 0,
                Offline = 1,
                Syncing = 2,
                Synced = 3,
                Failed = 4,
                IncompatibleVersion = 5,
                NetworkNeedsUpdate = 6,
            }
            impl SyncStatus {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        Self::Unknown => "Unknown",
                        Self::Offline => "Offline",
                        Self::Syncing => "Syncing",
                        Self::Synced => "Synced",
                        Self::Failed => "Failed",
                        Self::IncompatibleVersion => "IncompatibleVersion",
                        Self::NetworkNeedsUpdate => "NetworkNeedsUpdate",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "Unknown" => Some(Self::Unknown),
                        "Offline" => Some(Self::Offline),
                        "Syncing" => Some(Self::Syncing),
                        "Synced" => Some(Self::Synced),
                        "Failed" => Some(Self::Failed),
                        "IncompatibleVersion" => Some(Self::IncompatibleVersion),
                        "NetworkNeedsUpdate" => Some(Self::NetworkNeedsUpdate),
                        _ => None,
                    }
                }
            }
        }
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct File {}
    /// Nested message and enum types in `File`.
    pub mod file {
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct LimitReached {
            #[prost(string, tag = "1")]
            pub space_id: ::prost::alloc::string::String,
            #[prost(string, tag = "2")]
            pub file_id: ::prost::alloc::string::String,
        }
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct SpaceUsage {
            #[prost(uint64, tag = "1")]
            pub bytes_usage: u64,
            #[prost(string, tag = "2")]
            pub space_id: ::prost::alloc::string::String,
        }
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct LocalUsage {
            #[prost(uint64, tag = "1")]
            pub local_bytes_usage: u64,
        }
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct LimitUpdated {
            #[prost(uint64, tag = "1")]
            pub bytes_limit: u64,
        }
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Membership {}
    /// Nested message and enum types in `Membership`.
    pub mod membership {
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Update {
            #[prost(message, optional, tag = "1")]
            pub data: ::core::option::Option<
                crate::anytype_proto::anytype_model::Membership,
            >,
        }
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Notification {}
    /// Nested message and enum types in `Notification`.
    pub mod notification {
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Send {
            #[prost(message, optional, tag = "1")]
            pub notification: ::core::option::Option<
                crate::anytype_proto::anytype_model::Notification,
            >,
        }
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Update {
            #[prost(message, optional, tag = "1")]
            pub notification: ::core::option::Option<
                crate::anytype_proto::anytype_model::Notification,
            >,
        }
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Payload {}
    /// Nested message and enum types in `Payload`.
    pub mod payload {
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Broadcast {
            #[prost(string, tag = "1")]
            pub payload: ::prost::alloc::string::String,
        }
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Space {}
    /// Nested message and enum types in `Space`.
    pub mod space {
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct SyncStatus {}
        /// Nested message and enum types in `SyncStatus`.
        pub mod sync_status {
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Update {
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                #[prost(enumeration = "super::Status", tag = "2")]
                pub status: i32,
                #[prost(enumeration = "super::Network", tag = "3")]
                pub network: i32,
                #[prost(enumeration = "super::SyncError", tag = "4")]
                pub error: i32,
                #[prost(int64, tag = "5")]
                pub syncing_objects_counter: i64,
            }
        }
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct AutoWidgetAdded {
            #[prost(string, tag = "1")]
            pub target_id: ::prost::alloc::string::String,
            /// pluralName (if exists) for types, fallback to name. Special cases for "bin" and "favorites"
            #[prost(string, tag = "2")]
            pub target_name: ::prost::alloc::string::String,
            #[prost(string, tag = "3")]
            pub widget_block_id: ::prost::alloc::string::String,
        }
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Status {
            Synced = 0,
            Syncing = 1,
            Error = 2,
            Offline = 3,
            NetworkNeedsUpdate = 4,
        }
        impl Status {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Synced => "Synced",
                    Self::Syncing => "Syncing",
                    Self::Error => "Error",
                    Self::Offline => "Offline",
                    Self::NetworkNeedsUpdate => "NetworkNeedsUpdate",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "Synced" => Some(Self::Synced),
                    "Syncing" => Some(Self::Syncing),
                    "Error" => Some(Self::Error),
                    "Offline" => Some(Self::Offline),
                    "NetworkNeedsUpdate" => Some(Self::NetworkNeedsUpdate),
                    _ => None,
                }
            }
        }
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Network {
            Anytype = 0,
            SelfHost = 1,
            LocalOnly = 2,
        }
        impl Network {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Anytype => "Anytype",
                    Self::SelfHost => "SelfHost",
                    Self::LocalOnly => "LocalOnly",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "Anytype" => Some(Self::Anytype),
                    "SelfHost" => Some(Self::SelfHost),
                    "LocalOnly" => Some(Self::LocalOnly),
                    _ => None,
                }
            }
        }
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum SyncError {
            Null = 0,
            StorageLimitExceed = 1,
            IncompatibleVersion = 2,
            NetworkError = 3,
        }
        impl SyncError {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Null => "Null",
                    Self::StorageLimitExceed => "StorageLimitExceed",
                    Self::IncompatibleVersion => "IncompatibleVersion",
                    Self::NetworkError => "NetworkError",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "Null" => Some(Self::Null),
                    "StorageLimitExceed" => Some(Self::StorageLimitExceed),
                    "IncompatibleVersion" => Some(Self::IncompatibleVersion),
                    "NetworkError" => Some(Self::NetworkError),
                    _ => None,
                }
            }
        }
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct P2pStatus {}
    /// Nested message and enum types in `P2PStatus`.
    pub mod p2p_status {
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Update {
            #[prost(string, tag = "1")]
            pub space_id: ::prost::alloc::string::String,
            #[prost(enumeration = "Status", tag = "2")]
            pub status: i32,
            #[prost(int64, tag = "3")]
            pub devices_counter: i64,
        }
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Status {
            NotConnected = 0,
            NotPossible = 1,
            Connected = 2,
            /// only for ios for now, fallback to NotPossible if not implemented on client
            Restricted = 3,
        }
        impl Status {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::NotConnected => "NotConnected",
                    Self::NotPossible => "NotPossible",
                    Self::Connected => "Connected",
                    Self::Restricted => "Restricted",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "NotConnected" => Some(Self::NotConnected),
                    "NotPossible" => Some(Self::NotPossible),
                    "Connected" => Some(Self::Connected),
                    "Restricted" => Some(Self::Restricted),
                    _ => None,
                }
            }
        }
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Import {}
    /// Nested message and enum types in `Import`.
    pub mod import {
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Finish {
            #[prost(string, tag = "1")]
            pub root_collection_id: ::prost::alloc::string::String,
            #[prost(int64, tag = "2")]
            pub objects_count: i64,
            #[prost(
                enumeration = "crate::anytype_proto::anytype_model::import::Type",
                tag = "3"
            )]
            pub import_type: i32,
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResponseEvent {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<event::Message>,
    #[prost(string, tag = "2")]
    pub context_id: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub trace_id: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EventModel {}
/// Nested message and enum types in `EventModel`.
pub mod event_model {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Process {
        #[prost(string, tag = "1")]
        pub id: ::prost::alloc::string::String,
        #[prost(enumeration = "process::State", tag = "3")]
        pub state: i32,
        #[prost(message, optional, tag = "4")]
        pub progress: ::core::option::Option<process::Progress>,
        #[prost(string, tag = "5")]
        pub space_id: ::prost::alloc::string::String,
        #[prost(string, tag = "11")]
        pub error: ::prost::alloc::string::String,
        #[prost(oneof = "process::Message", tags = "6, 7, 8, 9, 10")]
        pub message: ::core::option::Option<process::Message>,
    }
    /// Nested message and enum types in `Process`.
    pub mod process {
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct DropFiles {}
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct Import {}
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct Export {}
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct SaveFile {}
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct Migration {}
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Progress {
            #[prost(int64, tag = "1")]
            pub total: i64,
            #[prost(int64, tag = "2")]
            pub done: i64,
            #[prost(string, tag = "3")]
            pub message: ::prost::alloc::string::String,
        }
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum State {
            None = 0,
            Running = 1,
            Done = 2,
            Canceled = 3,
            Error = 4,
        }
        impl State {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::None => "None",
                    Self::Running => "Running",
                    Self::Done => "Done",
                    Self::Canceled => "Canceled",
                    Self::Error => "Error",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "None" => Some(Self::None),
                    "Running" => Some(Self::Running),
                    "Done" => Some(Self::Done),
                    "Canceled" => Some(Self::Canceled),
                    "Error" => Some(Self::Error),
                    _ => None,
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
        pub enum Message {
            #[prost(message, tag = "6")]
            DropFiles(DropFiles),
            #[prost(message, tag = "7")]
            Import(Import),
            #[prost(message, tag = "8")]
            Export(Export),
            #[prost(message, tag = "9")]
            SaveFile(SaveFile),
            #[prost(message, tag = "10")]
            Migration(Migration),
        }
    }
}
/// the element of change tree used to store and internal apply smartBlock history
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Change {
    /// set of actions to apply
    #[prost(message, repeated, tag = "3")]
    pub content: ::prost::alloc::vec::Vec<change::Content>,
    /// snapshot - when not null, the Content will be ignored
    #[prost(message, optional, tag = "4")]
    pub snapshot: ::core::option::Option<change::Snapshot>,
    /// file keys related to changes content
    #[prost(message, repeated, tag = "6")]
    pub file_keys: ::prost::alloc::vec::Vec<change::FileKeys>,
    /// creation timestamp
    #[prost(int64, tag = "7")]
    pub timestamp: i64,
    /// version of business logic
    #[prost(uint32, tag = "8")]
    pub version: u32,
}
/// Nested message and enum types in `Change`.
pub mod change {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Snapshot {
        /// logId -> lastChangeId
        #[prost(map = "string, string", tag = "1")]
        pub log_heads: ::std::collections::HashMap<
            ::prost::alloc::string::String,
            ::prost::alloc::string::String,
        >,
        /// snapshot data
        #[prost(message, optional, tag = "2")]
        pub data: ::core::option::Option<
            crate::anytype_proto::anytype_model::SmartBlockSnapshotBase,
        >,
        /// all file keys related to doc
        #[prost(message, repeated, tag = "3")]
        pub file_keys: ::prost::alloc::vec::Vec<FileKeys>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct FileKeys {
        #[prost(string, tag = "1")]
        pub hash: ::prost::alloc::string::String,
        #[prost(map = "string, string", tag = "2")]
        pub keys: ::std::collections::HashMap<
            ::prost::alloc::string::String,
            ::prost::alloc::string::String,
        >,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Content {
        #[prost(
            oneof = "content::Value",
            tags = "1, 2, 3, 4, 5, 50, 51, 100, 101, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115"
        )]
        pub value: ::core::option::Option<content::Value>,
    }
    /// Nested message and enum types in `Content`.
    pub mod content {
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Value {
            #[prost(message, tag = "1")]
            BlockCreate(super::BlockCreate),
            #[prost(message, tag = "2")]
            BlockUpdate(super::BlockUpdate),
            #[prost(message, tag = "3")]
            BlockRemove(super::BlockRemove),
            #[prost(message, tag = "4")]
            BlockMove(super::BlockMove),
            #[prost(message, tag = "5")]
            BlockDuplicate(super::BlockDuplicate),
            #[prost(message, tag = "50")]
            RelationAdd(super::RelationAdd),
            #[prost(message, tag = "51")]
            RelationRemove(super::RelationRemove),
            #[prost(message, tag = "100")]
            DetailsSet(super::DetailsSet),
            #[prost(message, tag = "101")]
            DetailsUnset(super::DetailsUnset),
            #[prost(message, tag = "105")]
            ObjectTypeAdd(super::ObjectTypeAdd),
            #[prost(message, tag = "106")]
            ObjectTypeRemove(super::ObjectTypeRemove),
            #[prost(message, tag = "107")]
            StoreKeySet(super::StoreKeySet),
            #[prost(message, tag = "108")]
            StoreKeyUnset(super::StoreKeyUnset),
            #[prost(message, tag = "109")]
            StoreSliceUpdate(super::StoreSliceUpdate),
            #[prost(message, tag = "110")]
            OriginalCreatedTimestampSet(super::OriginalCreatedTimestampSet),
            #[prost(message, tag = "111")]
            SetFileInfo(super::SetFileInfo),
            #[prost(message, tag = "112")]
            NotificationCreate(super::NotificationCreate),
            #[prost(message, tag = "113")]
            NotificationUpdate(super::NotificationUpdate),
            #[prost(message, tag = "114")]
            DeviceAdd(super::DeviceAdd),
            #[prost(message, tag = "115")]
            DeviceUpdate(super::DeviceUpdate),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct BlockCreate {
        #[prost(string, tag = "1")]
        pub target_id: ::prost::alloc::string::String,
        #[prost(
            enumeration = "crate::anytype_proto::anytype_model::block::Position",
            tag = "2"
        )]
        pub position: i32,
        #[prost(message, repeated, tag = "3")]
        pub blocks: ::prost::alloc::vec::Vec<crate::anytype_proto::anytype_model::Block>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct BlockUpdate {
        #[prost(message, repeated, tag = "2")]
        pub events: ::prost::alloc::vec::Vec<super::event::Message>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct BlockRemove {
        #[prost(string, repeated, tag = "1")]
        pub ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct BlockMove {
        #[prost(string, tag = "1")]
        pub target_id: ::prost::alloc::string::String,
        #[prost(
            enumeration = "crate::anytype_proto::anytype_model::block::Position",
            tag = "2"
        )]
        pub position: i32,
        #[prost(string, repeated, tag = "3")]
        pub ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct BlockDuplicate {
        #[prost(string, tag = "1")]
        pub target_id: ::prost::alloc::string::String,
        #[prost(
            enumeration = "crate::anytype_proto::anytype_model::block::Position",
            tag = "2"
        )]
        pub position: i32,
        #[prost(string, repeated, tag = "3")]
        pub ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DetailsSet {
        #[prost(string, tag = "1")]
        pub key: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "2")]
        pub value: ::core::option::Option<::prost_types::Value>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DetailsUnset {
        #[prost(string, tag = "1")]
        pub key: ::prost::alloc::string::String,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RelationAdd {
        #[prost(message, repeated, tag = "1")]
        pub relation_links: ::prost::alloc::vec::Vec<
            crate::anytype_proto::anytype_model::RelationLink,
        >,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RelationRemove {
        #[prost(string, repeated, tag = "1")]
        pub relation_key: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ObjectTypeAdd {
        #[prost(string, tag = "1")]
        pub url: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub key: ::prost::alloc::string::String,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ObjectTypeRemove {
        #[prost(string, tag = "1")]
        pub url: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub key: ::prost::alloc::string::String,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct StoreKeySet {
        #[prost(string, repeated, tag = "1")]
        pub path: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(message, optional, tag = "2")]
        pub value: ::core::option::Option<::prost_types::Value>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct StoreKeyUnset {
        #[prost(string, repeated, tag = "1")]
        pub path: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct StoreSliceUpdate {
        #[prost(string, tag = "1")]
        pub key: ::prost::alloc::string::String,
        #[prost(oneof = "store_slice_update::Operation", tags = "2, 3, 4")]
        pub operation: ::core::option::Option<store_slice_update::Operation>,
    }
    /// Nested message and enum types in `StoreSliceUpdate`.
    pub mod store_slice_update {
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Add {
            #[prost(string, tag = "1")]
            pub after_id: ::prost::alloc::string::String,
            #[prost(string, repeated, tag = "2")]
            pub ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        }
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Remove {
            #[prost(string, repeated, tag = "1")]
            pub ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        }
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Move {
            #[prost(string, tag = "1")]
            pub after_id: ::prost::alloc::string::String,
            #[prost(string, repeated, tag = "2")]
            pub ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        }
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Operation {
            #[prost(message, tag = "2")]
            Add(Add),
            #[prost(message, tag = "3")]
            Remove(Remove),
            #[prost(message, tag = "4")]
            Move(Move),
        }
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct OriginalCreatedTimestampSet {
        #[prost(int64, tag = "1")]
        pub ts: i64,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SetFileInfo {
        #[prost(message, optional, tag = "1")]
        pub file_info: ::core::option::Option<
            crate::anytype_proto::anytype_model::FileInfo,
        >,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct NotificationCreate {
        #[prost(message, optional, tag = "1")]
        pub notification: ::core::option::Option<
            crate::anytype_proto::anytype_model::Notification,
        >,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct NotificationUpdate {
        #[prost(string, tag = "1")]
        pub id: ::prost::alloc::string::String,
        #[prost(
            enumeration = "crate::anytype_proto::anytype_model::notification::Status",
            tag = "2"
        )]
        pub status: i32,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DeviceAdd {
        #[prost(message, optional, tag = "1")]
        pub device: ::core::option::Option<
            crate::anytype_proto::anytype_model::DeviceInfo,
        >,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DeviceUpdate {
        #[prost(string, tag = "1")]
        pub id: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub name: ::prost::alloc::string::String,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChangeNoSnapshot {
    /// set of actions to apply
    #[prost(message, repeated, tag = "3")]
    pub content: ::prost::alloc::vec::Vec<change::Content>,
    /// file keys related to changes content
    #[prost(message, repeated, tag = "6")]
    pub file_keys: ::prost::alloc::vec::Vec<change::FileKeys>,
    /// creation timestamp
    #[prost(int64, tag = "7")]
    pub timestamp: i64,
    /// version of business logic
    #[prost(uint32, tag = "8")]
    pub version: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StoreChange {
    #[prost(message, repeated, tag = "1")]
    pub change_set: ::prost::alloc::vec::Vec<StoreChangeContent>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StoreChangeContent {
    #[prost(oneof = "store_change_content::Change", tags = "1, 2, 3")]
    pub change: ::core::option::Option<store_change_content::Change>,
}
/// Nested message and enum types in `StoreChangeContent`.
pub mod store_change_content {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Change {
        #[prost(message, tag = "1")]
        Create(super::DocumentCreate),
        #[prost(message, tag = "2")]
        Modify(super::DocumentModify),
        #[prost(message, tag = "3")]
        Delete(super::DocumentDelete),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DocumentCreate {
    #[prost(string, tag = "1")]
    pub collection: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub document_id: ::prost::alloc::string::String,
    /// json
    #[prost(string, tag = "3")]
    pub value: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DocumentModify {
    #[prost(string, tag = "1")]
    pub collection: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub document_id: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "4")]
    pub keys: ::prost::alloc::vec::Vec<KeyModify>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KeyModify {
    /// key path; example: \[user, email\]
    #[prost(string, repeated, tag = "1")]
    pub key_path: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// modify op: set, unset, inc, etc.
    #[prost(enumeration = "ModifyOp", tag = "3")]
    pub modify_op: i32,
    /// json value; example: '"new@email.com"'
    #[prost(string, tag = "4")]
    pub modify_value: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DocumentDelete {
    #[prost(string, tag = "1")]
    pub collection: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub document_id: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ModifyOp {
    Set = 0,
    Unset = 1,
    Inc = 2,
    AddToSet = 3,
    Pull = 4,
}
impl ModifyOp {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Set => "Set",
            Self::Unset => "Unset",
            Self::Inc => "Inc",
            Self::AddToSet => "AddToSet",
            Self::Pull => "Pull",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "Set" => Some(Self::Set),
            "Unset" => Some(Self::Unset),
            "Inc" => Some(Self::Inc),
            "AddToSet" => Some(Self::AddToSet),
            "Pull" => Some(Self::Pull),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SnapshotWithType {
    #[prost(
        enumeration = "crate::anytype_proto::anytype_model::SmartBlockType",
        tag = "1"
    )]
    pub sb_type: i32,
    #[prost(message, optional, tag = "2")]
    pub snapshot: ::core::option::Option<change::Snapshot>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Profile {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub avatar: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub address: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub space_dashboard_id: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub profile_id: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub analytics_id: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub starting_page: ::prost::alloc::string::String,
}

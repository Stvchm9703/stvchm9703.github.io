import{a as e,o as t}from"./BtALZkK9.js";var r=/\s+/g,n=(...e)=>{const t=[],n=e=>{if(!e&&0!==e&&0n!==e)return;if(Array.isArray(e)){for(let t=0,r=e.length;t<r;t++)n(e[t]);return}const r=typeof e;if("string"===r||"number"===r||"bigint"===r){if("number"===r&&e!=e)return;t.push(String(e))}else if("object"===r){const r=Object.keys(e);for(let n=0,s=r.length;n<s;n++){const s=r[n];e[s]&&t.push(s)}}};for(let r=0,o=e.length;r<o;r++){const t=e[r];null!=t&&n(t)}return t.length>0?"string"==typeof(s=t.join(" "))&&s?s.replace(r," ").trim():s:void 0;var s},s=e=>!1===e?"false":!0===e?"true":0===e?"0":e,o=e=>{if(!e||"object"!=typeof e)return!0;for(const t in e)return!1;return!0},i=(e,t)=>{for(let r=0;r<e.length;r++){const n=e[r];Array.isArray(n)?i(n,t):n&&t.push(n)}},c=(...e)=>{const t=[];i(e,t);const r=[];for(let n=0;n<t.length;n++)t[n]&&r.push(t[n]);return r},a=(e,t)=>{const r={};for(const n in e){const s=e[n];if(n in t){const e=t[n];Array.isArray(s)||Array.isArray(e)?r[n]=c(e,s):r[n]="object"==typeof s&&"object"==typeof e&&s&&e?a(s,e):e+" "+s}else r[n]=s}for(const n in t)n in e||(r[n]=t[n]);return r},l={twMerge:!0,twMergeConfig:{}};var f=function(){let e=null,t={},r=!1;return{get cachedTwMerge(){return e},set cachedTwMerge(t){e=t},get cachedTwMergeConfig(){return t},set cachedTwMergeConfig(e){t=e},get didTwMergeConfigChange(){return r},set didTwMergeConfigChange(e){r=e},reset(){e=null,t={},r=!1}}}(),u=(r,s)=>{const i=n(r);return i&&(s?.twMerge??1)?(f.cachedTwMerge&&!f.didTwMergeConfigChange||(f.didTwMergeConfigChange=!1,f.cachedTwMerge=(c=f.cachedTwMergeConfig,o(c)?t:e({...c,extend:{theme:c.theme,classGroups:c.classGroups,conflictingClassGroupModifiers:c.conflictingClassGroupModifiers,conflictingClassGroups:c.conflictingClassGroups,...c.extend}}))),f.cachedTwMerge(i)||void 0):i;var c},{createTV:g,tv:d}=(e=>{const t=(t,r)=>{const{extend:i=null,slots:u={},variants:g={},compoundVariants:d=[],compoundSlots:p=[],defaultVariants:h={}}=t,y={...l,...r},b=i?.base?n(i.base,t?.base):t?.base,w=i?.variants&&!o(i.variants)?a(g,i.variants):g,C=i?.defaultVariants&&!o(i.defaultVariants)?{...i.defaultVariants,...h}:h;o(y.twMergeConfig)||((e,t)=>{if(e===t)return!0;if(!e||!t)return!1;const r=Object.keys(e),n=Object.keys(t);if(r.length!==n.length)return!1;for(let s=0;s<r.length;s++){const o=r[s];if(!n.includes(o))return!1;if(e[o]!==t[o])return!1}return!0})(y.twMergeConfig,f.cachedTwMergeConfig)||(f.didTwMergeConfigChange=!0,f.cachedTwMergeConfig=y.twMergeConfig);const M=o(i?.slots),m=o(u)?{}:{base:n(t?.base,M&&i?.base),...u},T=M?m:((e,t)=>{for(const r in t)if(Object.prototype.hasOwnProperty.call(t,r)){const s=t[r];e[r]=r in e?n(e[r],s):s}return e})({...i?.slots},o(m)?{base:t?.base}:m),v=o(i?.compoundVariants)?d:c(i?.compoundVariants,d),j=t=>{if(o(w)&&o(u)&&M)return e(b,t?.class,t?.className)(y);if(v&&!Array.isArray(v))throw new TypeError('The "compoundVariants" prop must be an array. Received: '+typeof v);if(p&&!Array.isArray(p))throw new TypeError('The "compoundSlots" prop must be an array. Received: '+typeof p);const r=(e,r=w,n=null,i=null)=>{const c=r[e];if(!c||o(c))return null;const a=i?.[e]??t?.[e];if(null===a)return null;const l=s(a);if("object"==typeof l)return null;const f=C?.[e];return c[(null!=l?l:s(f))||"false"]},n=(e,t)=>{if(!w||"object"!=typeof w)return null;const n=[];for(const s in w){const o=r(s,w,e,t),i="base"===e&&"string"==typeof o?o:o&&o[e];i&&n.push(i)}return n},i={};for(const e in t){const r=t[e];void 0!==r&&(i[e]=r)}const c=(e,r)=>{const n="object"==typeof t?.[e]?{[e]:t[e]?.initial}:{};return{...C,...i,...n,...r}},a=(e=[],t)=>{const r=[],n=e.length;for(let s=0;s<n;s++){const{class:n,className:o,...i}=e[s];let a=!0;const l=c(null,t);for(const e in i){const t=i[e],r=l[e];if(Array.isArray(t)){if(!t.includes(r)){a=!1;break}}else{if(!(null!=t&&!1!==t||null!=r&&!1!==r))continue;if(r!==t){a=!1;break}}}a&&(n&&r.push(n),o&&r.push(o))}return r},l=t=>{const r=a(v,t);if(!Array.isArray(r))return r;const n={},s=e;for(let e=0;e<r.length;e++){const t=r[e];if("string"==typeof t)n.base=s(n.base,t)(y);else if("object"==typeof t)for(const e in t)n[e]=s(n[e],t[e])(y)}return n},f=e=>{if(p.length<1)return null;const t={},r=c(null,e);for(let n=0;n<p.length;n++){const{slots:e=[],class:s,className:i,...c}=p[n];if(!o(c)){let e=!0;for(const t in c){const n=r[t],s=c[t];if(void 0===n||(Array.isArray(s)?!s.includes(n):s!==n)){e=!1;break}}if(!e)continue}for(let r=0;r<e.length;r++){const n=e[r];t[n]||(t[n]=[]),t[n].push([s,i])}}return t};if(!o(u)||!M){const t={};if("object"==typeof T&&!o(T)){const r=e;for(const e in T)t[e]=t=>{const s=l(t),o=f(t);return r(T[e],n(e,t),s?s[e]:void 0,o?o[e]:void 0,t?.class,t?.className)(y)}}return t}return e(b,(()=>{if(!w)return null;const e=Object.keys(w),t=[];for(let n=0;n<e.length;n++){const s=r(e[n],w);s&&t.push(s)}return t})(),a(v),t?.class,t?.className)(y)};return j.variantKeys=(()=>{if(w&&"object"==typeof w)return Object.keys(w)})(),j.extend=i,j.base=b,j.slots=T,j.variants=w,j.defaultVariants=C,j.compoundSlots=p,j.compoundVariants=v,j};return{tv:t,createTV:e=>(r,n)=>t(r,n?a(e,n):e)}})((...e)=>t=>u(e,t));export{d as t};
import{d as e,f as r,g as t,h as a,m as s,n,p as i,s as o,t as l}from"./BjEUid_f.js";var d=class extends l{static#e=r(this,"TreemapTokenBuilder");constructor(){super(["treemap"])}},c=/classDef\s+([A-Z_a-z]\w+)(?:\s+([^\n\r;]*))?;?/,m=class extends n{static#e=r(this,"TreemapValueConverter");runCustomConverter(e,r,t){if("NUMBER2"===e.name)return parseFloat(r.replace(/,/g,""));if("SEPARATOR"===e.name)return r.substring(1,r.length-1);if("STRING2"===e.name)return r.substring(1,r.length-1);if("INDENTATION"===e.name)return r.length;if("ClassDef"===e.name){if("string"!=typeof r)return r;const e=c.exec(r);if(e)return{$type:"ClassDefStatement",className:e[1],styleText:e[2]||void 0}}}};function p(e){const r=e.validation.TreemapValidator,t=e.validation.ValidationRegistry;if(t){const e={Treemap:r.checkSingleRoot.bind(r)};t.register(e,r)}}r(p,"registerValidationChecks");var u=class{static#e=r(this,"TreemapValidator");checkSingleRoot(e,r){let t;for(const a of e.TreemapRows)a.item&&(void 0===t&&void 0===a.indent?t=0:(void 0===a.indent||void 0!==t&&t>=parseInt(a.indent,10))&&r("error","Multiple root nodes are not allowed in a treemap.",{node:a,property:"item"}))}},f={parser:{TokenBuilder:r(()=>new d,"TokenBuilder"),ValueConverter:r(()=>new m,"ValueConverter")},validation:{TreemapValidator:r(()=>new u,"TreemapValidator")}};function T(r=i){const n=s(t(r),o),l=s(a({shared:n}),e,f);return n.ServiceRegistry.register(l),p(l),{shared:n,Treemap:l}}r(T,"createTreemapServices");export{T as n,f as t};